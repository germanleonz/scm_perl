.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RPC::XML 3"
.TH RPC::XML 3 "2011-08-22" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RPC::XML \- A set of classes for core data, message and XML handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use RPC::XML;
\&
\&    $req = RPC::XML::request\->new(\*(Aqfetch_prime_factors\*(Aq,
\&                                  RPC::XML::int\->new(985_120_528));
\&    ...
\&    $resp = RPC::XML::ParserFactory\->new()\->parse(STREAM);
\&    if (ref($resp))
\&    {
\&        return $resp\->value\->value;
\&    }
\&    else
\&    {
\&        die $resp;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\s-1RPC::XML\s0\fR package is an implementation of the \fBXML-RPC\fR standard. The
package as a whole provides classes for data, for clients, for servers and for
parsers (based on the XML::Parser and XML::LibXML
packages from \s-1CPAN\s0).
.PP
This module provides a set of classes for creating values to pass to the
constructors for requests and responses. These are lightweight objects, most of
which are implemented as blessed scalar references so as to associate specific
type information with the value. Classes are also provided for requests,
responses and faults (errors).
.PP
This module does not actually provide any transport implementation or server
basis. For these, see RPC::XML::Client and
RPC::XML::Server, respectively.
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
At present, two subroutines are available for import. They must be explicitly
imported as part of the \f(CW\*(C`use\*(C'\fR statement, or with a direct call to \f(CW\*(C`import\*(C'\fR:
.IP "time2iso8601([$time])" 4
.IX Item "time2iso8601([$time])"
Convert the integer time value in \f(CW$time\fR (which defaults to calling the
built-in \f(CW\*(C`time\*(C'\fR if not present) to a (pseudo) \s-1ISO\s0 8601 string in the \s-1UTC\s0 time
zone. This is a convenience function for occassions when the return value needs
to be of the \fBdateTime.iso8601\fR type, but the value on hand is the return from
the \f(CW\*(C`time\*(C'\fR built-in. Note that the format of this string is not strictly
compliant with \s-1ISO\s0 8601 due to the way the \fBdateTime.iso8601\fR data-type was
defined in the specification. See \*(L"\s-1DATES\s0 \s-1AND\s0 \s-1TIMES\s0\*(R", below.
.IP "smart_encode(@args)" 4
.IX Item "smart_encode(@args)"
Converts the passed-in arguments to datatype objects. Any that are already
encoded as such are passed through unchanged. The routine is called recursively
on hash and array references. Note that this routine can only deduce a certain
degree of detail about the values passed. Boolean values will be wrongly
encoded as integers. Pretty much anything not specifically recognizable will
get encoded as a string object. Thus, for types such as \f(CW\*(C`fault\*(C'\fR, the \s-1ISO\s0
time value, base\-64 data, etc., the program must still explicitly encode it.
However, this routine will hopefully simplify things a little bit for a
majority of the usage cases.
.Sp
If an argument is a blessed reference (an object), \fBsmart_encode\fR will
generally treat it as a non-blessed reference of the underlying type. That
is, objects based on hash references will be encoded as if they are unblessed
hash references (becoming \fBRPC::XML::struct\fR objects), objects based on
array references are encoded as array references (\fBRPC::XML::array\fR), etc.
Only hash references, array references and scalar references are treated in
this fashion; any other blessed references cannot be down-graded and will
cause an exception to be thrown.
.Sp
The exception to this are objects of the \fBDateTime\fR class: this package does
not utilize \fBDateTime\fR directly, but if you pass in a reference to an
existing object of that class, it is properly converted to an object of the
\&\fBRPC::XML::datetime_iso8601\fR class.
.PP
In addition to these, the following \*(L"helper\*(R" functions are also available. They
may be imported explicitly, or all may be imported via the tag \f(CW\*(C`:types\*(C'\fR:
.PP
.Vb 2
\&    RPC_BOOLEAN RPC_INT RPC_I4 RPC_I8 RPC_DOUBLE
\&    RPC_DATETIME_ISO8601 RPC_BASE64 RPC_STRING RPC_NIL
.Ve
.PP
Each creates a data object of the appropriate type from a single value
(or, in the case of \fB\s-1RPC_NIL\s0\fR, from no value). They are merely short\-
hand for calling the constructors of the data classes directly.
.PP
All of the above (helpers and the first two functions) may be imported via
the tag \f(CW\*(C`:all\*(C'\fR.
.SH "CLASSES"
.IX Header "CLASSES"
The classes provided by this module are broken into two groups: \fIdata\fR
classes and \fImessage\fR classes.
.SS "Data Classes"
.IX Subsection "Data Classes"
The following data classes are provided by this library. Each of these provide
at least the set of methods below. Note that these classes are designed to
create throw-away objects. There is currently no mechanism for changing the
value stored within one of these object after the constructor returns. It is
assumed that a new object would be created, instead.
.PP
The common methods to all data classes are:
.IP "new($value)" 4
.IX Item "new($value)"
Constructor. The value passed in is the value to be encapsulated in the new
object.
.IP "value" 4
.IX Item "value"
Returns the value kept in the object. Processes recursively for \f(CW\*(C`array\*(C'\fR and
\&\f(CW\*(C`struct\*(C'\fR objects.
.IP "as_string" 4
.IX Item "as_string"
Returns the value as a XML-RPC fragment, with the proper tags, etc.
.IP "serialize($filehandle)" 4
.IX Item "serialize($filehandle)"
Send the stringified rendition of the data to the given file handle. This
allows messages with arbitrarily-large base\-64 data within them to be sent
without having to hold the entire message within process memory.
.IP "length" 4
.IX Item "length"
Returns the length, in bytes, of the object when serialized into \s-1XML\s0. This is
used by the client and server classes to calculate message length.
.IP "type" 4
.IX Item "type"
Returns the type of data being stored in an object. The type matches the
XML-RPC specification, so the normalized form \f(CW\*(C`datetime_iso8601\*(C'\fR comes back
as \f(CW\*(C`dateTime.iso8601\*(C'\fR.
.IP "is_fault" 4
.IX Item "is_fault"
All types except the fault class return false for this. This is to allow
consistent testing of return values for fault status, without checking for a
hash reference with specific keys defined.
.PP
The classes themselves are:
.IP "RPC::XML::int" 4
.IX Item "RPC::XML::int"
Creates an integer value. Constructor expects the integer value as an
argument.
.IP "RPC::XML::i4" 4
.IX Item "RPC::XML::i4"
This is like the \f(CW\*(C`int\*(C'\fR class. Note that services written in strictly-typed
languages such as C, \*(C+ or Java may consider the \f(CW\*(C`i4\*(C'\fR and \f(CW\*(C`int\*(C'\fR types as
distinct and different.
.IP "RPC::XML::i8" 4
.IX Item "RPC::XML::i8"
This represents an 8\-byte integer, and is not officially supported by the
XML-RPC specification. This has been added to accommodate services already
in use that have chosen to add this extension.
.IP "RPC::XML::double" 4
.IX Item "RPC::XML::double"
Creates a floating-point value.
.IP "RPC::XML::string" 4
.IX Item "RPC::XML::string"
Creates an arbitrary string. No special encoding is done to the string (aside
from \s-1XML\s0 document encoding, covered later) with the exception of the \f(CW\*(C`<\*(C'\fR,
\&\f(CW\*(C`>\*(C'\fR and \f(CW\*(C`&\*(C'\fR characters, which are XML-escaped during object creation,
and then reverted when the \f(CW\*(C`value\*(C'\fR method is called.
.IP "RPC::XML::boolean" 4
.IX Item "RPC::XML::boolean"
Creates a boolean value. The value returned will always be either of \fB1\fR
or \fB0\fR, for true or false, respectively. When calling the constructor, the
program may specify any of: \f(CW0\fR, \f(CW\*(C`no\*(C'\fR, \f(CW\*(C`false\*(C'\fR, \f(CW1\fR, \f(CW\*(C`yes\*(C'\fR, \f(CW\*(C`true\*(C'\fR.
.IP "RPC::XML::datetime_iso8601" 4
.IX Item "RPC::XML::datetime_iso8601"
Creates an instance of the XML-RPC \f(CW\*(C`dateTime.iso8601\*(C'\fR type. The specification
for \s-1ISO\s0 8601 may be found elsewhere. No processing is done to the data. Note
that the XML-RPC specification actually got the format of an \s-1ISO\s0 8601 date
slightly wrong. Because this is what is in the published spec, this package
produces dates that match the XML-RPC spec, not the the \s-1ISO\s0 8601 spec. However,
it will \fIread\fR date-strings in proper \s-1ISO\s0 8601 format. See \*(L"\s-1DATES\s0 \s-1AND\s0
\&\s-1TIMES\s0\*(R", below.
.IP "RPC::XML::nil" 4
.IX Item "RPC::XML::nil"
Creates a \f(CW\*(C`nil\*(C'\fR value. The value returned will always be \fBundef\fR. No value
should be passed when calling the constructor.
.Sp
Note that nil is an extension to \fBXML-RPC\fR, which is not supported by all
implementations. \fB\f(CB$RPC::XML::ALLOW_NIL\fB\fR must be set to a non-false value
before objects of this type can be constructed. See \*(L"\s-1GLOBAL\s0
\&\s-1VARIABLES\s0\*(R". However, even if \fB\f(CB$RPC::XML::ALLOW_NIL\fB\fR is set to a false value,
the parsers will recognize the \f(CW\*(C`<nil />\*(C'\fR tag and construct an object.
.Sp
In practice, this type is only useful to denote the equivalent of a \*(L"void\*(R"
return value from a function. The type itself is not interchangeable with
any of the other data-types.
.IP "RPC::XML::base64" 4
.IX Item "RPC::XML::base64"
Creates an object that encapsulates a chunk of data that will be treated as
base\-64 for transport purposes. The value may be passed in as either a string
or as a scalar reference. Additionally, a second (optional) parameter may be
passed, that if true identifies the data as already base\-64 encoded. If so,
the data is decoded before storage. The \f(CW\*(C`value\*(C'\fR method returns decoded data,
and the \f(CW\*(C`as_string\*(C'\fR method encodes it before stringification.
.Sp
Alternately, the constructor may be given an open filehandle argument instead
of direct data. When this is the case, the data is never read into memory in
its entirety, unless the \f(CW\*(C`value\*(C'\fR or \f(CW\*(C`as_string\*(C'\fR methods are called. This
allows the manipulation of arbitrarily-large Base\-64\-encoded data chunks. In
these cases, the flag (optional second argument) is still relevant, but the
data is not pre-decoded if it currently exists in an encoded form. It is only
decoded as needed. Note that the filehandle passed must be open for reading,
at least. It will not be written to, but it will be read from. The position
within the file will be preserved between operations.
.Sp
Because of this, this class supports a special method called \f(CW\*(C`to_file\*(C'\fR, that
takes one argument. The argument may be either an open, writable filehandle or
a string. If it is a string, \f(CW\*(C`to_file\*(C'\fR will attempt to open it as a file and
write the \fIdecoded\fR data to it. If the argument is a an open filehandle, the
data will be written to it without any pre\- or post-adjustment of the handle
position (nor will it be closed upon completion). This differs from the
\&\f(CW\*(C`serialize\*(C'\fR method in that it always writes the decoded data (where the other
always writes encoded data), and in that the \s-1XML\s0 opening and closing tags are
not written. The return value of \f(CW\*(C`to_file\*(C'\fR is the size of the data written
in bytes.
.IP "RPC::XML::array" 4
.IX Item "RPC::XML::array"
Creates an array object. The constructor takes zero or more data-type
instances as arguments, which are inserted into the array in the order
specified. \f(CW\*(C`value\*(C'\fR returns an array reference of native Perl types. If a
non-null value is passed as an argument to \f(CW\*(C`value()\*(C'\fR, then the array
reference will contain datatype objects (a shallow rather than deep copy).
.IP "RPC::XML::struct" 4
.IX Item "RPC::XML::struct"
Creates a struct object, the analogy of a hash table in Perl. The keys are
ordinary strings, and the values must all be data-type objects. The \f(CW\*(C`value\*(C'\fR
method returns a hash table reference, with native Perl types in the values.
Key order is not preserved. Key strings are now encoded for special \s-1XML\s0
characters, so the use of such (\f(CW\*(C`<\*(C'\fR, \f(CW\*(C`>\*(C'\fR, etc.) should be
transparent to the user. If a non-null value is passed as an argument to
\&\f(CW\*(C`value()\*(C'\fR, then the hash reference will contain the datatype objects rather
than native Perl data (a shallow vs. deep copy, as with the array type above).
.Sp
When creating \fBRPC::XML::struct\fR objects, there are two ways to pass the
content in for the new object: Either an existing hash reference may be passed,
or a series of key/value pairs may be passed. If a reference is passed, the
existing data is copied (the reference is not re-blessed), with the values
encoded into new objects as needed.
.IP "RPC::XML::fault" 4
.IX Item "RPC::XML::fault"
A fault object is a special case of the struct object that checks to ensure
that there are two keys, \f(CW\*(C`faultCode\*(C'\fR and \f(CW\*(C`faultString\*(C'\fR.
.Sp
As a matter of convenience, since the contents of a \fBRPC::XML::fault\fR
structure are specifically defined, the constructor may be called with exactly
two arguments, the first of which will be taken as the code, and the second
as the string. They will be converted to \s-1RPC::XML\s0 types automatically and
stored by the pre-defined key names.
.Sp
Also as a matter of convenience, the fault class provides the following
accessor methods for directly retrieving the integer code and error string
from a fault object:
.RS 4
.IP "code" 4
.IX Item "code"
.PD 0
.IP "string" 4
.IX Item "string"
.RE
.RS 4
.PD
.Sp
Both names should be self-explanatory. The values returned are Perl values,
not \fB\s-1RPC::XML\s0\fR class instances.
.RE
.SS "Message Classes"
.IX Subsection "Message Classes"
The message classes are used both for constructing messages for outgoing
communication as well as representing the parsed contents of a received
message. Both implement the following methods:
.IP "new" 4
.IX Item "new"
This is the constructor method for the two message classes. The response class
may have only a single value (as a response is currently limited to a single
return value), and requests may have as many arguments as appropriate. In both
cases, the arguments are passed to the exported \f(CW\*(C`smart_encode\*(C'\fR routine
described earlier.
.IP "as_string" 4
.IX Item "as_string"
Returns the message object expressed as an \s-1XML\s0 document. The document will be
lacking in linebreaks and indention, as it is not targeted for human reading.
.IP "serialize($filehandle)" 4
.IX Item "serialize($filehandle)"
Serialize the message to the given file-handle. This avoids creating the entire
\&\s-1XML\s0 message within memory, which may be relevant if there is especially-large
Base\-64 data within the message.
.IP "length" 4
.IX Item "length"
Returns the total size of the message in bytes, used by the client and server
classes to set the Content-Length header.
.PP
The two message-object classes are:
.IP "RPC::XML::request" 4
.IX Item "RPC::XML::request"
This creates a request object. A request object expects the first argument to
be the name of the remote routine being called, and all remaining arguments
are the arguments to that routine. Request objects have the following methods
(besides \f(CW\*(C`new\*(C'\fR and \f(CW\*(C`as_string\*(C'\fR):
.RS 4
.IP "name" 4
.IX Item "name"
The name of the remote routine that the request will call.
.IP "args" 4
.IX Item "args"
Returns a list reference with the arguments that will be passed. No arguments
will result in a reference to an empty list.
.RE
.RS 4
.RE
.IP "RPC::XML::response" 4
.IX Item "RPC::XML::response"
The response object is much like the request object in most ways. It may
take only one argument, as that is all the specification allows for in a
response. Responses have the following methods (in addition to \f(CW\*(C`new\*(C'\fR and
\&\f(CW\*(C`as_string\*(C'\fR):
.RS 4
.IP "value" 4
.IX Item "value"
The value the response is returning. It will be a \s-1RPC::XML\s0 data-type.
.IP "is_fault" 4
.IX Item "is_fault"
A boolean test whether or not the response is signalling a fault. This is
the same as taking the \f(CW\*(C`value\*(C'\fR method return value and testing it, but is
provided for clarity and simplicity.
.RE
.RS 4
.RE
.SH "DATES AND TIMES"
.IX Header "DATES AND TIMES"
The XML-RPC specification refers to the date/time values as \s-1ISO\s0 8601, but
unfortunately got the syntax slightly wrong in the examples. However, since
this is the published specification it is necessary to produce time-stamps that
conform to this format. The specification implies that the only format for
date/time values is:
.PP
.Vb 1
\&    YYYYMMDDThh:mm:ss
.Ve
.PP
(Here, the \f(CW\*(C`T\*(C'\fR is literal, the rest represent elements of the date and time.)
However, the \s-1ISO\s0 8601 specification does not allow this particular format, and
in generally is \fIconsiderably\fR more flexible than this.  Yet there are
implementations of the XML-RPC standard in other languages that rely on a
strict interpretation of this format.
.PP
To accommodate this, the \fB\s-1RPC::XML\s0\fR package only produces \fBdateTime.iso8601\fR
values in the format given in the spec, with the possible addition of timezone
information if the string used to create a \fBRPC::XML::datetime_iso8601\fR
instance included a timezone offset. The string passed in to the constructor
for that class must match:
.PP
.Vb 1
\&    \ed\ed\ed\ed\-?\ed\ed\-?\ed\edT?\ed\ed:\ed\ed:\ed\ed([.,]\ed+)?(Z|[\-+]\ed\ed:\ed\ed)?
.Ve
.PP
This pattern is also used by \fBsmart_encode\fR to distinguish a date/time string
from a regular string. Note that the \f(CW\*(C`T\*(C'\fR is optional here, as it is in the
\&\s-1ISO\s0 8601 spec. The timezone is optional, and if it is not given then \s-1UTC\s0 is
assumed. The XML-RPC specification says not to assume anything about the
timezone in the absence of one, but the format of \s-1ISO\s0 8601 declares that that
absence of an explicit timezone dictates \s-1UTC\s0.
.PP
If you have DateTime::Format::ISO8601 installed,
then \fBRPC::XML::datetime_iso8601\fR will fall back on it to try and parse any
input strings that do not match the above pattern. If the string cannot be
parsed by the \fBDateTime::Format::ISO8601\fR module, then the constructor returns
\&\fBundef\fR and \fB\f(CB$RPC::XML::ERROR\fB\fR is set.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
All constructors (in all data classes) return \f(CW\*(C`undef\*(C'\fR upon failure, with the
error message available in the package-global variable \fB\f(CB$RPC::XML::ERROR\fB\fR.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
The following global variables may be changed to control certain behavior of
the library. All variables listed below may be imported into the application
namespace when you \f(CW\*(C`use\*(C'\fR \fB\s-1RPC::XML\s0\fR:
.ie n .IP "$ENCODING" 4
.el .IP "\f(CW$ENCODING\fR" 4
.IX Item "$ENCODING"
This variable controls the character-set encoding reported in outgoing \s-1XML\s0
messages. It defaults to \f(CW\*(C`us\-ascii\*(C'\fR, but may be set to any value recognized
by \s-1XML\s0 parsers.
.ie n .IP "$FORCE_STRING_ENCODING" 4
.el .IP "\f(CW$FORCE_STRING_ENCODING\fR" 4
.IX Item "$FORCE_STRING_ENCODING"
By default, \f(CW\*(C`smart_encode\*(C'\fR uses heuristics to determine what encoding
is required for a data type. For example, \f(CW123\fR would be encoded as \f(CW\*(C`int\*(C'\fR,
where \f(CW3.14\fR would be encoded as \f(CW\*(C`double\*(C'\fR. In some situations it may be
handy to turn off all these heuristics, and force encoding of \f(CW\*(C`string\*(C'\fR on
all data types encountered during encoding. Setting this flag to \f(CW\*(C`true\*(C'\fR
will do just that.
.Sp
Defaults to \f(CW\*(C`false\*(C'\fR.
.ie n .IP "$ALLOW_NIL" 4
.el .IP "\f(CW$ALLOW_NIL\fR" 4
.IX Item "$ALLOW_NIL"
By default, the XML-RPC \f(CW\*(C`nil\*(C'\fR extension is not supported. Set this to a
non-false value to allow use of nil values. Data objects that are \f(CW\*(C`nil\*(C'\fR
are represented as \fBundef\fR by Perl. See \*(L"The nil Datatype\*(R".
.SH "CAVEATS"
.IX Header "CAVEATS"
This began as a reference implementation in which clarity of process and
readability of the code took precedence over general efficiency. It is now
being maintained as production code, but may still have parts that could be
written more efficiently.
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-rpc\-xml at rt.cpan.org\*(C'\fR, or through the web interface at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=RPC\-XML <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=RPC-XML>. I will be
notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
.IP "\(bu" 4
\&\s-1RT:\s0 \s-1CPAN\s0's request tracker
.Sp
http://rt.cpan.org/NoAuth/Bugs.html?Dist=RPC\-XML <http://rt.cpan.org/NoAuth/Bugs.html?Dist=RPC-XML>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
http://annocpan.org/dist/RPC\-XML <http://annocpan.org/dist/RPC-XML>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
http://cpanratings.perl.org/d/RPC\-XML <http://cpanratings.perl.org/d/RPC-XML>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
http://search.cpan.org/dist/RPC\-XML <http://search.cpan.org/dist/RPC-XML>
.IP "\(bu" 4
MetaCPAN
.Sp
https://metacpan.org/release/RPC\-XML <https://metacpan.org/release/RPC-XML>
.IP "\(bu" 4
Source code on GitHub
.Sp
http://github.com/rjray/rpc\-xml <http://github.com/rjray/rpc-xml>
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
This file and the code within are copyright (c) 2011 by Randy J. Ray.
.PP
Copying and distribution are permitted under the terms of the Artistic
License 2.0 (http://www.opensource.org/licenses/artistic\-license\-2.0.php <http://www.opensource.org/licenses/artistic-license-2.0.php>) or
the \s-1GNU\s0 \s-1LGPL\s0 2.1 (http://www.opensource.org/licenses/lgpl\-2.1.php <http://www.opensource.org/licenses/lgpl-2.1.php>).
.SH "CREDITS"
.IX Header "CREDITS"
The \fBXML-RPC\fR standard is Copyright (c) 1998\-2001, UserLand Software, Inc.
See <http://www.xmlrpc.com> for more information about the \fBXML-RPC\fR
specification.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
RPC::XML::Client, RPC::XML::Server
.SH "AUTHOR"
.IX Header "AUTHOR"
Randy J. Ray <rjray@blackperl.com>
